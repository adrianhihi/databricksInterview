
# Customer Revenue System 题解 + 实时 Top-K Follow-up（Java 实现）

> 说明用中文，代码注释用英文，方便面试时讲解。

---

## 一、题目总结（Customer Revenue System）

### 1. 英文题干简要

We need to design a `RevenueSystem` to track customer revenues:

- When a customer generates revenue, the system records the amount and the associated customer.
- Customers can **refer** new customers. When a referred customer generates revenue, that amount is credited to **both**:
  - the referred customer (their own revenue),
  - and the referrer (as referral revenue).

**Total revenue** of a customer = their own revenue + the revenue generated by the customers they **directly referred** (not multi-level).

We must implement:

- `RevenueSystem()`  
  Initialize the system.

- `int add(int revenue)`  
  Add a new customer with `revenue` (no referrer).  
  Return a unique auto-incremented id starting from **0**.

- `int addByReferral(int revenue, int referrerId)`  
  Add a new customer with `revenue`, referred by `referrerId`.  
  - The new customer’s total revenue includes this `revenue`.
  - The referrer’s total revenue also increases by `revenue`.  
  Return the new customer’s id.  
  If `referrerId` is invalid, return `-1` and do nothing.

- `List<Integer> getTopKCustomer(int k, int minRevenue)`  
  Return up to `k` customer IDs:
  - with total revenue **≥ `minRevenue`**,
  - sorted by **total revenue descending** (ties can be broken by id ascending).  
  IDs are unique in the result.

---

## 二、基础解法：TreeSet 维护全局排序

### 1. 思路说明

核心需求：

- 需要支持不断新增客户 / 推荐关系；
- 需要频繁按「总营收」做 Top-K 排行查询。

朴素思路：

1. 每个客户维护一个 `total`：
   - `add(revenue)`：新客户 total = revenue。
   - `addByReferral(revenue, referrerId)`：
     - 新客户 total = revenue；
     - 推荐人 total += revenue。

2. 使用：
   - `Map<Integer, Customer>` 通过 id 找到对应对象，方便更新；
   - `TreeSet<Customer>` 按 `total` **降序** + `id` **升序** 排序：
     - 每次 total 变化时，从 `TreeSet` 中先删除旧对象，再插入更新后的对象，保证排序正确。

3. 查询 `getTopKCustomer(k, minRevenue)` 时：
   - 直接从 `TreeSet` 的首元素开始迭代（已经是最大 total 的客户）；
   - 依次选出 `total >= minRevenue` 的前 `k` 个；
   - 一旦遇到 `total < minRevenue`，后面都更小，可以直接 break。

### 2. 时间复杂度

设当前有 `N` 个客户：

- `add` / `addByReferral`：
  - 插入/删除 `TreeSet` 的复杂度约为 `O(log N)`；
  - 所以更新操作是 `O(log N)`。

- `getTopKCustomer`：
  - 最好情况：`k` 很小而且 `minRevenue` 很高，只用扫少量元素，近似 `O(k)`；
  - 最坏情况：`minRevenue` 很低，需要从头扫到尾，复杂度为 `O(N)`。

在一般面试环境中，这已经是 **非常合理且实现简单的基准解法**。

### 3. Java 实现（TreeSet 版本）

> 为了避免与后面的 Heap 版本类名冲突，这里命名为 `RevenueSystemTreeSet`。  
> 逻辑与你写的版本基本一致，只是稍微重排了一下注释方便讲解。

```java
import java.util.*;

/**
 * Baseline implementation using TreeSet to maintain a global sorted ranking.
 * - ID is auto-incremented from 0.
 * - Each customer has a total revenue.
 * - A TreeSet keeps all customers ordered by (total desc, id asc).
 */
public class RevenueSystemTreeSet {

    // Represents a customer in the system.
    private static class Customer {
        int id;
        long total; // use long to avoid overflow when sums get large

        Customer(int id, long total) {
            this.id = id;
            this.total = total;
        }
    }

    private int nextId;                          // next ID to assign
    private Map<Integer, Customer> customers;    // id -> Customer
    private TreeSet<Customer> sorted;           // customers ordered by (total desc, id asc)

    public RevenueSystemTreeSet() {
        nextId = 0;
        customers = new HashMap<>();

        // Comparator: higher total first; if tie, smaller id first
        sorted = new TreeSet<>(new Comparator<Customer>() {
            @Override
            public int compare(Customer a, Customer b) {
                int cmp = Long.compare(b.total, a.total); // descending by total
                if (cmp != 0) return cmp;
                return Integer.compare(a.id, b.id);       // ascending by id on tie
            }
        });
    }

    /**
     * Adds a new customer with the given revenue.
     * This customer has no referrer.
     * Returns the assigned customer ID.
     */
    public int add(int revenue) {
        int id = nextId;
        Customer cust = new Customer(id, revenue);
        customers.put(id, cust);
        sorted.add(cust);
        nextId++;
        return id;
    }

    /**
     * Adds a new customer with the given revenue, referred by referrerId.
     * - The new customer gets total = revenue.
     * - The referrer also increases total by revenue.
     * If referrerId is invalid, returns -1 and does nothing.
     */
    public int addByReferral(int revenue, int referrerId) {
        Customer ref = customers.get(referrerId);
        if (ref == null) {
            return -1; // invalid referrer
        }

        // 1) create the referred customer
        int id = nextId;
        Customer cust = new Customer(id, revenue);
        customers.put(id, cust);
        sorted.add(cust);

        // 2) update referrer's total:
        //    - remove from TreeSet (old key)
        //    - modify total
        //    - re-insert into TreeSet (new key)
        sorted.remove(ref);
        ref.total += revenue;
        sorted.add(ref);

        nextId++;
        return id;
    }

    /**
     * Returns up to k customer IDs whose total revenue >= minRevenue.
     * The result is ordered by total descending (id ascending as tie-break).
     */
    public List<Integer> getTopKCustomer(int k, int minRevenue) {
        List<Integer> result = new ArrayList<>();
        int count = 0;

        for (Customer c : sorted) {
            if (count == k) break;          // already collected k customers
            if (c.total < minRevenue) break; // all following totals will be <= this value

            result.add(c.id);
            count++;
        }

        return result;
    }

    // Small demo main (optional for testing)
    public static void main(String[] args) {
        RevenueSystemTreeSet system = new RevenueSystemTreeSet();
        System.out.println(system.add(100));           // 0
        System.out.println(system.add(50));            // 1
        System.out.println(system.addByReferral(30, 0)); // 2
        System.out.println(system.addByReferral(70, 1)); // 3
        System.out.println(system.add(50));            // 4
        System.out.println(system.getTopKCustomer(2, 100)); // [0, 1]
        System.out.println(system.addByReferral(50, 4));   // 5
        System.out.println(system.getTopKCustomer(3, 100)); // [0, 1, 4]
    }
}
```

---

## 三、Follow-up：如何做「实时 Top-K」（Streaming Top-K）

### 1. 面试官真正想问什么？

当面试官问：**“How to support real-time Top-K?”**  
通常是在问：

- 用户数 `N` 可能很大（百万级、千万级）；
- `add` / `addByReferral` 这样的更新会不断流入（streaming）；
- `getTopKCustomer` 的调用非常频繁；
- 不希望每次查询都扫一遍所有客户（`O(N)`），更不希望每次都重新 sort (`O(N log N)`)。

他们希望你能：

> 在更新的同时，把 Top-K 的信息维护在一个**小的专用数据结构**里，  
> 让查询 Top-K 的复杂度不依赖于 `N`，而只依赖于 `K`。

### 2. 设计目标

我们希望：

- **更新（add / addByReferral）**：仍然是 `O(log K)` 或 `O(log N)`；
- **查询（getTopKCustomer）**：在大规模下尽量做到 `O(K log K)` 或更低，而不是 `O(N)`。

典型套路：

- 维护一个 `Map<Integer, Long>` 来记录每个 id 的当前 total；
- 再维护一个容量为 `Kmax` 的 **最小堆（min-heap）**，里面存的是“目前全局 Top-K 候选人”；
  - 堆顶是这 K 个里 **最小的 total**；  
  - 如果新的 total 比堆顶还小，就没必要进 Top-K；  
  - 如果更大，则把它放进堆里，同时弹出一个最小的候选人。

这里有个关键点：

- **总营收只会增加，不会减少**（题意是“新增收入”）；
- 为了简化，我们可以允许堆里存在“过期快照”（stale nodes）：
  - 例如，同一个 id 可能被插入多次，每次是当时的 total 快照；
  - 查询时再“懒删除（lazy cleanup）”：只用最新的 total。

### 3. 数据结构设计（Heap 版本）

我们做一个独立实现：`RevenueSystemTopKHeap`；

- `nextId`：下一个可用 id；
- `List<Long> totals`：索引 = customer id，值 = 当前 total；
- `int Kmax`：系统支持的最大 Top-K 容量（比如 100 或 1000）；
- `PriorityQueue<Node> topKMinHeap`：
  - `Node` 结构：`(id, snapshotTotal)`；
  - min-heap 按 `snapshotTotal` 升序；
  - size 最多 `Kmax`，维护的是“Top-K 候选人”。

**重要假设**：  
- 实际使用时，我们会让 `Kmax` ≥ 系统可能查询的最大 `k`；  
- 如果系统需要更大的 `k`，要么调大 `Kmax`，要么回退到 TreeSet/全量扫描方案。

### 4. 更新流程：add / addByReferral

1. **add(revenue)**：
   - 分配新 id = `nextId`；
   - `totals[id] = revenue`；
   - 调用 `updateTopK(id)` 尝试把这个客户加入 Top-K 最小堆。

2. **addByReferral(revenue, referrerId)**：
   - 检查 referrerId 是否在有效范围 [0, nextId)；无效则返回 -1；
   - 新客户 id = `nextId`，`totals[newId] = revenue`；
   - 同时 `totals[referrerId] += revenue`；
   - 对这两个 id 分别调用 `updateTopK(...)`。

`updateTopK(int id)` 的逻辑（伪代码）：

```text
newTotal = totals[id]

if topKMinHeap.size < Kmax:
    push (id, newTotal)
else:
    if newTotal <= topKMinHeap.peek().snapshotTotal:
        // smaller than the current K-th largest, ignore
        return
    else:
        // candidate is large enough to be inside Top-K
        push (id, newTotal)
        if size > Kmax:
            poll() one smallest snapshot
```

> 因为 total 只会增长，且我们允许堆中存在旧快照（过期节点），  
> 只要每次 total 变大时都有机会入堆，就能保证“真正的 Top-K 客户都在堆中”。

### 5. 查询流程：getTopKCustomer(k, minRevenue)

1. 从 `topKMinHeap` 中枚举所有 Node（堆大小 <= Kmax）；
2. 对每个 Node：
   - 用 `id` 查询当前真实 total：`curTotal = totals.get(id)`；
   - 如果 `curTotal >= minRevenue` 且这个 id 还没被选过，就放到一个 **最大堆 maxHeap** 中（按 total 降序）；
3. 最后从 `maxHeap` 中弹出最多 `k` 个元素，依次取出 id 即可。

复杂度：

- 枚举 `topKMinHeap`：O(Kmax)；
- 构建 `maxHeap`：O(Kmax logKmax)；
- 弹出前 `k`：O(k logKmax)；

总体是 `O(Kmax log Kmax)`，与总人数 `N` 无关。  
在 `Kmax << N` 的情况下，这对大量实时查询非常友好。

### 6. Java 实现（Heap Top-K 版本）

> 这里的类不再用 `TreeSet`，完全靠 `List<Long> totals` + Min-Heap 做 Top-K。  
> 为了演示 Follow-up 思路，命名为 `RevenueSystemTopKHeap`。

```java
import java.util.*;

/**
 * Follow-up implementation focusing on real-time Top-K.
 *
 * Idea:
 * - Maintain only an approximate "Top-K view" using a min-heap of size <= Kmax.
 * - For each customer, we maintain current total revenue in a list (index = id).
 * - On each revenue change, we push a snapshot (id, totalAtInsert) into the min-heap
 *   if it is large enough to potentially belong to the global Top-K.
 * - Because revenue only increases, and we allow stale snapshots in the heap,
 *   we can still recover the correct Top-K by checking the latest totals lazily.
 */
public class RevenueSystemTopKHeap {

    // Node used inside the min-heap (Top-K candidates).
    private static class Node {
        int id;
        long snapshotTotal; // the total at the time this node was inserted

        Node(int id, long snapshotTotal) {
            this.id = id;
            this.snapshotTotal = snapshotTotal;
        }
    }

    private int nextId;                // next customer ID to assign
    private final int Kmax;           // maximum K that we want to support efficiently
    private List<Long> totals;        // totals.get(id) = current total revenue for that customer
    private PriorityQueue<Node> topKMinHeap; // min-heap by snapshotTotal

    /**
     * Constructor with a configurable Kmax.
     * Kmax should be >= the largest K you expect in getTopKCustomer calls.
     */
    public RevenueSystemTopKHeap(int Kmax) {
        this.nextId = 0;
        this.Kmax = Kmax;
        this.totals = new ArrayList<>();
        // Min-heap ordered by snapshotTotal ascending
        this.topKMinHeap = new PriorityQueue<>(new Comparator<Node>() {
            @Override
            public int compare(Node a, Node b) {
                return Long.compare(a.snapshotTotal, b.snapshotTotal);
            }
        });
    }

    /**
     * Adds a new customer with the given revenue (no referrer).
     * Returns the new customer ID.
     */
    public int add(int revenue) {
        int id = nextId;
        long total = revenue;

        // store the current total
        totals.add(total); // index = id

        // update the Top-K heap with this new customer
        pushTopKCandidate(id, total);

        nextId++;
        return id;
    }

    /**
     * Adds a new customer with the given revenue, referred by referrerId.
     * - The new customer has total = revenue.
     * - The referrer also increases total by revenue.
     * Returns the new customer ID,
     * or -1 if referrerId is invalid.
     */
    public int addByReferral(int revenue, int referrerId) {
        // Validate referrerId: must be an existing customer
        if (referrerId < 0 || referrerId >= nextId) {
            return -1;
        }

        // 1) create the referred customer
        int newId = nextId;
        long referredTotal = revenue;
        totals.add(referredTotal);

        // 2) update referrer total
        long refOldTotal = totals.get(referrerId);
        long refNewTotal = refOldTotal + revenue;
        totals.set(referrerId, refNewTotal);

        // 3) push candidates to Top-K heap
        pushTopKCandidate(newId, referredTotal);
        pushTopKCandidate(referrerId, refNewTotal);

        nextId++;
        return newId;
    }

    /**
     * Helper method to push a (id, total) snapshot into the Top-K min-heap.
     * We keep the heap size <= Kmax.
     */
    private void pushTopKCandidate(int id, long total) {
        if (Kmax <= 0) {
            return; // no Top-K tracking if Kmax == 0
        }

        if (topKMinHeap.size() < Kmax) {
            topKMinHeap.offer(new Node(id, total));
            return;
        }

        Node minNode = topKMinHeap.peek();
        if (minNode == null) {
            // should not happen, but guard anyway
            topKMinHeap.offer(new Node(id, total));
            return;
        }

        // If the new total is not bigger than the smallest in the Top-K heap,
        // this customer does not belong to the global Top-K.
        if (total <= minNode.snapshotTotal) {
            return;
        }

        // Otherwise, insert the new snapshot
        topKMinHeap.offer(new Node(id, total));

        // Ensure heap size <= Kmax by removing one smallest snapshot
        if (topKMinHeap.size() > Kmax) {
            topKMinHeap.poll();
        }
    }

    /**
     * Returns up to k customer IDs whose total revenue >= minRevenue,
     * sorted by total revenue descending.
     *
     * NOTE:
     * - This method only considers customers in the Top-K view (the min-heap).
     * - If you need an exact answer for k > Kmax, you must either:
     *   1) increase Kmax, or
     *   2) fall back to a full scan over all customers.
     */
    public List<Integer> getTopKCustomer(int k, int minRevenue) {
        List<Integer> result = new ArrayList<>();
        if (k <= 0 || Kmax <= 0) {
            return result;
        }

        // Build a max-heap of valid candidates from the Top-K min-heap.
        // We filter by:
        //   - latest total (not by the snapshotTotal in the Node),
        //   - minRevenue,
        //   - unique customer ID (since there may be multiple snapshots for the same id).
        PriorityQueue<Node> maxHeap = new PriorityQueue<>(new Comparator<Node>() {
            @Override
            public int compare(Node a, Node b) {
                return Long.compare(b.snapshotTotal, a.snapshotTotal); // descending by total
            }
        });

        Set<Integer> seen = new HashSet<>();

        // Enumerate candidates in topKMinHeap (size <= Kmax)
        for (Node node : topKMinHeap) {
            int id = node.id;
            if (id < 0 || id >= totals.size()) continue;

            if (seen.contains(id)) {
                // already considered this customer
                continue;
            }

            long currentTotal = totals.get(id);
            if (currentTotal < minRevenue) {
                // does not satisfy minRevenue
                continue;
            }

            seen.add(id);
            maxHeap.offer(new Node(id, currentTotal));
        }

        // Extract top k by total descending
        while (k > 0 && !maxHeap.isEmpty()) {
            Node node = maxHeap.poll();
            result.add(node.id);
            k--;
        }

        return result;
    }

    // Small demo main (optional).
    public static void main(String[] args) {
        // Suppose we want to support up to K = 3 efficiently.
        RevenueSystemTopKHeap system = new RevenueSystemTopKHeap(3);

        System.out.println(system.add(100));              // 0
        System.out.println(system.add(50));               // 1
        System.out.println(system.addByReferral(30, 0));  // 2
        System.out.println(system.addByReferral(70, 1));  // 3
        System.out.println(system.add(50));               // 4

        System.out.println(system.getTopKCustomer(2, 100)); // e.g. [0, 1]
        System.out.println(system.addByReferral(50, 4));    // 5
        System.out.println(system.getTopKCustomer(3, 100)); // e.g. [0, 1, 4]
    }
}
```

---

## 四、TreeSet 版 vs Heap 版：如何在面试中讲

### 1. TreeSet 版本（你现在的解法）

- **优点**：
  - 实现简单、语义清晰；
  - 所有客户始终按 total 全局有序；
  - `add` / `addByReferral` 都是 `O(log N)`；
  - `getTopKCustomer` 最好情况接近 `O(k)`，平均表现也不错。

- **缺点**：
  - 在极端情况（比如 `minRevenue` 很低、N 很大、查询非常多），  
    `getTopKCustomer` 最坏仍然要扫到 `O(N)`。

### 2. Heap Top-K 版本（Follow-up）

- **优点**：
  - 专门为“实时排名 / 实时 Top-K 查询”优化；
  - 增量更新只需要对一个大小为 `Kmax` 的堆做操作：
    - `pushTopKCandidate` 大致为 `O(log Kmax)`；
  - 查询只依赖 `Kmax`，复杂度约为 `O(Kmax log Kmax)`，与 `N` 无关。

- **缺点 / Trade-off**：
  - 需要选定一个合理的 `Kmax`，并约定查询的 `k <= Kmax`；
  - 数据结构更复杂，需要解释“懒删除”和“快照”概念；  
  - 如果需要对任意 `k` 做精确 Top-K（尤其是 k 很大），依然可能需要回退到全量扫描或 TreeSet 方案。

在面试场景下，你可以这样总结：

> - **基线版本**：用 `TreeSet` 维护全局有序，`add` 和 `addByReferral` 是 `O(log N)`，`getTopKCustomer` 在平均情况下足够快，是一个工程中很实用且好实现的方案。  
> - **Follow-up 优化**：如果系统是一个典型的“实时排行榜 / streaming Top-K”场景，用户数很大、查询 Top-K 非常频繁，那我会引入一个 `Kmax` 级别的 min-heap，仅维护 Top-K 视图，将查询复杂度降到与 K 相关，而不是与 N 相关。

你可以根据面试官的追问程度，在 TreeSet 版和 Heap 版之间切换讲解深度。

---

> 如果你之后还需要：  
> - 再加一层“支持分页排行榜”（比如 Top-K 再配合 offset），  
> - 或者把这题包装成一个 system design / leaderboard 服务，  
> 我也可以帮你继续往上抽象成 service + API + 存储层设计。

---

## 五、Follow-up 2：多层 Referral（Multi-level Referral Tree）

这个 follow-up 相当于把题目从「只算直接推荐」升级为「算整个推荐树的所有后代」，也就是：

> 某个 customer 的 total = 自己的 revenue + 所有被 TA 直接或间接推荐出来的客户的 revenue 总和。

### 1. 语义变化

原题定义：

> A customer's total revenue is defined as the sum of their own revenue and the revenue generated by the customers they directly referred.

Follow-up 要求改为：

> A customer's total revenue should include the revenue generated by all **descendants** in the referral chain (not just direct children).

也就是说，如果有链路：

- 0 → 1 → 2 → 3 （箭头代表“被谁推荐”）

当 3 产生一笔 revenue 时：

- 3 自己 total += rev
- 2 total += rev
- 1 total += rev
- 0 total += rev

### 2. 思路：给每个客户加一个 parentId

在基础 TreeSet 版本中，每个 `Customer` 只有：

- `id`
- `total`

现在我们增加一个字段：

- `parentId`：该客户的直接推荐人（referrer）；
  - 如果是通过 `add(revenue)` 创建的（无推荐人），则 `parentId = -1`；
  - 如果是通过 `addByReferral(revenue, referrerId)` 创建的，则 `parentId = referrerId`。

这样，所有 referral 关系会构成一棵树（或多棵树组成的森林），我们可以从任何一个节点一路向上找到所有祖先。

### 3. 更新逻辑变化

- `add(revenue)`：
  - 和原来一样，新建一个 root 节点：`parentId = -1`，`total = revenue`；
  - 插入 `customers` 和 `sorted`。

- `addByReferral(revenue, referrerId)`：
  1. 检查 `referrerId` 是否有效；
  2. 创建 child：`parentId = referrerId`，`total = revenue`；
  3. 从 `referrer` 开始，一路向上：
     - 对每个祖先节点 `cur`：
       - 从 `sorted` 里 `remove(cur)`；
       - `cur.total += revenue`；
       - 再 `add(cur)` 回 `sorted`；

这样就能保证：

- 所有祖先的 total 都包含了当前 child 的 revenue；
- TreeSet 中的排序也被正确更新。

### 4. 复杂度分析

设：

- 当前共有 `N` 个 customer；
- referral 树的高度（从某个节点往上数祖先的最大层数）为 `H`。

则：

- `add(revenue)`：`O(log N)`；
- `addByReferral(revenue, referrerId)`：
  - 需要对每个祖先做一次 TreeSet 更新（remove + add），每次是 `O(log N)`；
  - 总复杂度约为 `O(H * log N)`；

如果 referral 链变成非常长的链表（极端情况），`H` 可以接近 `N`，复杂度就会较高；  
但在一般业务里，referral 链的深度往往是可控的（比如十几层以内），这个复杂度是可以接受的。

### 5. 多层 Referral 的 TreeSet 实现

下面是基于「基础 TreeSet 版本」改写的多层 referral 版本，修改点在注释里用 `// *** MOD:` 标出，方便你面试时对照讲解。

```java
import java.util.*;

/**
 * RevenueSystem with multi-level referral:
 * - Each customer has a parentId (its referrer).
 * - A customer's total = own revenue + all revenue from its descendants
 *   in the referral tree (direct and indirect).
 *
 * Based on the basic TreeSet solution.
 */
public class RevenueSystem {

    // Represents a customer in the system.
    private static class Customer {
        int id;
        long total;      // total revenue including descendants
        int parentId;    // *** MOD: store direct referrer; -1 if none

        Customer(int id, long total, int parentId) { // *** MOD: add parentId
            this.id = id;
            this.total = total;
            this.parentId = parentId;
        }
    }

    private int nextId;                          // next ID to assign
    private Map<Integer, Customer> customers;    // id -> Customer
    private TreeSet<Customer> sorted;           // ordered by (total desc, id asc)

    public RevenueSystem() {
        nextId = 0;
        customers = new HashMap<>();

        // Comparator: higher total first; if tie, smaller id first
        sorted = new TreeSet<>(new Comparator<Customer>() {
            @Override
            public int compare(Customer a, Customer b) {
                int cmp = Long.compare(b.total, a.total); // descending by total
                if (cmp != 0) return cmp;
                return Integer.compare(a.id, b.id);       // ascending by id on tie
            }
        });
    }

    /**
     * Adds a new customer with the given revenue (no referrer).
     * For multi-level referral, this customer is a root: parentId = -1.
     */
    public int add(int revenue) {
        int id = nextId;

        // *** MOD: parentId = -1 because this is not referred by anyone.
        Customer cust = new Customer(id, revenue, -1);

        customers.put(id, cust);
        sorted.add(cust);
        nextId++;
        return id;
    }

    /**
     * Adds a new customer with the given revenue, referred by referrerId.
     *
     * Multi-level rule:
     * - The new customer gets total = revenue.
     * - The referrer and all its ancestors in the referral chain
     *   increase their total by revenue.
     *
     * Returns the new customer's ID,
     * or -1 if referrerId is invalid.
     */
    public int addByReferral(int revenue, int referrerId) {
        Customer ref = customers.get(referrerId);
        if (ref == null) {
            return -1; // invalid referrer
        }

        // 1) create the referred customer (child)
        // *** MOD: store parentId = referrerId
        int id = nextId;
        Customer child = new Customer(id, revenue, referrerId);
        customers.put(id, child);
        sorted.add(child);

        // 2) Propagate revenue to referrer and all its ancestors.
        //    Walk up the parent chain and update each ancestor's total.
        long delta = revenue;
        Customer cur = ref;

        while (cur != null) {
            // remove old snapshot from TreeSet
            sorted.remove(cur);
            // increase total by delta
            cur.total += delta;
            // reinsert updated snapshot
            sorted.add(cur);

            // move to parent
            if (cur.parentId == -1) {
                break;  // reached root
            }
            cur = customers.get(cur.parentId);
        }

        nextId++;
        return id;
    }

    /**
     * Returns up to k customer IDs whose total revenue >= minRevenue,
     * sorted by total descending (id ascending as tie-break).
     *
     * This logic is unchanged from the basic version.
     */
    public List<Integer> getTopKCustomer(int k, int minRevenue) {
        List<Integer> result = new ArrayList<>();
        int count = 0;

        for (Customer c : sorted) {
            if (count == k) break;
            if (c.total < minRevenue) break; // all following totals will be smaller

            result.add(c.id);
            count++;
        }

        return result;
    }

    // Small demo main
    public static void main(String[] args) {
        RevenueSystem system = new RevenueSystem();

        int a = system.add(100);             // 0, root
        int b = system.addByReferral(50, a); // 1, child of 0
        int c = system.addByReferral(30, b); // 2, child of 1
        int d = system.addByReferral(20, c); // 3, child of 2

        // Structure:
        // 0
        //  └─ 1
        //      └─ 2
        //          └─ 3
        //
        // Revenue:
        // 3: 20
        // 2: 30 + 20 = 50
        // 1: 50 + 30 + 20 = 100
        // 0: 100 + 50 + 30 + 20 = 200

        System.out.println("Total for 0 (expect 200) = " + system.customers.get(0).total);
        System.out.println("Total for 1 (expect 100) = " + system.customers.get(1).total);
        System.out.println("Total for 2 (expect 50)  = " + system.customers.get(2).total);
        System.out.println("Total for 3 (expect 20)  = " + system.customers.get(3).total);

        System.out.println("Top 3, minRevenue = 30: " + system.getTopKCustomer(3, 30));
    }
}
```

### 6. 面试时的简短讲法模板

> 在基础版里，total 只包含“自己 + 直接下级”的 revenue。  
> 如果要支持多层 referral，把 total 定义成“自己 + 所有后代”的 revenue。  
> 实现上我会给每个 customer 加一个 `parentId` 字段，表示它的直接推荐人。  
> `addByReferral` 时，除了给新 customer 设置 `parentId = referrerId`，还会从 referrer 开始沿着 `parentId` 一路往上走到根，把这条祖先链上的所有节点的 total 都加上这笔 revenue，并在 TreeSet 中做一次 remove + add 来更新排序。  
> 这样就能保证 TreeSet 始终按“multi-level total” 排序，`getTopKCustomer` 的逻辑无需修改。  
> 时间复杂度方面，单次 addByReferral 是 `O(H log N)`，H 是 referral 树的高度，通常在业务中是可控的。
